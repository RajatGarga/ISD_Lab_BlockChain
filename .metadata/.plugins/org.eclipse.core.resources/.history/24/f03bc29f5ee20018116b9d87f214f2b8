import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.security.KeyPair;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.gson.JsonObject;

import BlockChain.Block;
import BlockChain.BlockChain;
import BlockChain.Constants;
import BlockChain.Transaction;
import election.candidate;
import election.position;
import utils.Crypto;
import utils.general;

public class testServ extends HttpServlet {

	KeyPair keys;
	BlockChain chain;
	HashMap<String, String> voters;
	ArrayList<candidate> candidates;
	ArrayList<position> positions;

	/**
	 * AutoGenerated
	 */
	private static final long serialVersionUID = -7286803566302157939L;

	public void init() throws ServletException {
		System.out.println("INIT TEST SERVER!");
		keys = Crypto.generateKeys();
		testServ.initVoters();
		voters = testServ.loadVoters();
		testServ.initCandidates();
		candidates = testServ.loadCandidates();
		positions.add(new position("President", 1));
		positions.add(new position("Vice President", 2));
		positions.get(0).addCandidate(candidates.get(0));
		positions.get(0).addCandidate(candidates.get(1));
		positions.get(1).addCandidate(candidates.get(2));
		positions.get(1).addCandidate(candidates.get(3));
		positions.get(1).addCandidate(candidates.get(4));
		int max_amount = 0;
		for(int i=0; i<positions.size(); i++) {
			int num = positions.get(i).getMaxWinners();
			max_amount += ((num)*(num+1))/2;
		}
		chain = new BlockChain(null);
		Block block = new Block(general.getTimeStamp(), chain.head.hashBlock());
		for(int i=0; i<voters.size(); i++) {
			Transaction tran = new Transaction(Crypto.getPublicKeyasString(keys),
					voters.get(voters.))
		}
		Transaction tran1 = new Transaction(Crypto.getPublicKeyasString(keys1), Crypto.getPrivateKeyasString(keys2),
				300, "genesis");
		tran1.sign(Crypto.getPrivateKeyasString(keys1));
		block.addTransaction(tran1.toJSON());
		block.setHeight(chain.head.getHeight() + 1);
		if (block.mine()) {
			Constants.addCode code = chain.addBlock(block, true);
			if (code == Constants.addCode.SUCCESS) {
				System.out.println("Successfully mined");
				// System.out.println(chain.toJSON());
			} else {
				System.out.println("An error occured : " + code);
			}
		}
	}

	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		// Set response content type
		response.setContentType("application/json");
		// Actual logic goes here.
		JsonObject json = new JsonObject();
		json.addProperty("sucess", "true");
		PrintWriter out = response.getWriter();
		out.println(json.toString());
	}

	public void destroy() {
		// do nothing.
	}

	private static void initVoters() {
		// TODO Must have a separate endpoint and to be done well before the date of
		// voting
		try {
			FileWriter fw = new FileWriter("myfile.csv");
			PrintWriter writer = new PrintWriter(fw);
			for (int i = 0; i < 10; i++) {
				KeyPair key = Crypto.generateKeys();
				writer.println(Crypto.getPrivateKeyasString(key) + "," + Crypto.getPublicKeyasString(key) + "\n");
			}
			writer.close();
		} catch (IOException ex) {
			System.out.println("An error occured :: " + ex.getMessage());
		}
	}

	private static HashMap<String, String> loadVoters() {
		try {
			BufferedReader reader = new BufferedReader(new FileReader("myfile.csv"));
			String line = null;
			Scanner scanner = null;
			int index = 0;
			HashMap<String, String> voters = new HashMap<String, String>();
			while ((line = reader.readLine()) != null) {
				scanner = new Scanner(line);
				scanner.useDelimiter(",");
				String privatekey = scanner.next();
				String publicKey = scanner.next();
				voters.put(privatekey, publicKey);
			}
			return voters;
		} catch (FileNotFoundException e) {
			System.out.println("An error occured :: " + e.getMessage());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}


	private static void initCandidates() {
		// TODO Must have a separate endpoint and to be done well before the date of
		// voting
		try {
			FileWriter fw = new FileWriter("candidatesfile.csv");
			PrintWriter writer = new PrintWriter(fw);
			for (int i = 0; i < 5; i++) {
				KeyPair key = Crypto.generateKeys();
				writer.println("Candidate " + i + ","
						+Crypto.getPrivateKeyasString(key) + ","
						+Crypto.getPublicKeyasString(key) + "\n");
			}
			writer.close();
		} catch (IOException ex) {
			System.out.println("An error occured :: " + ex.getMessage());
		}
	}
	private static ArrayList<candidate> loadCandidates() {
		try {
			BufferedReader reader = new BufferedReader(new FileReader("myfile.csv"));
			String line = null;
			Scanner scanner = null;
			int index = 0;
			ArrayList<candidate> candidates = new ArrayList<candidate>();
			while ((line = reader.readLine()) != null) {
				scanner = new Scanner(line);
				scanner.useDelimiter(",");
				String name = scanner.next();
				String privatekey = scanner.next();
				String publicKey = scanner.next();
				candidates.add(new candidate(name,publicKey, privatekey));
			}
			return candidates;
		} catch (FileNotFoundException e) {
			System.out.println("An error occured :: " + e.getMessage());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
}